<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="_curve__impl_8tpp" kind="file" language="C++">
    <compoundname>Curve_impl.tpp</compoundname>
    <includedby refid="curve_8cpp" local="no">curve.cpp</includedby>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">#include<sp/>&quot;Curve_impl.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;ossia/editor/value/value.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;ossia/network/base/node.hpp&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>ossia</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">namespace<sp/>detail</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">curve_impl&lt;X,<sp/>Y&gt;::curve_impl()<sp/>=<sp/>default;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">curve_impl&lt;X,<sp/>Y&gt;::~curve_impl()<sp/>=<sp/>default;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>curve_impl&lt;X,<sp/>Y&gt;::addPoint(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ossia::curve_segment&lt;Y&gt;<sp/>segment,<sp/>X<sp/>abscissa,<sp/>Y<sp/>value)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mPointsMap.emplace(abscissa,<sp/>std::make_pair(value,<sp/>std::move(segment)));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>curve_impl&lt;X,<sp/>Y&gt;::removePoint(X<sp/>abscissa)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>mPointsMap.erase(abscissa)<sp/>&gt;<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">Y<sp/>curve_impl&lt;X,<sp/>Y&gt;::valueAt(X<sp/>abscissa)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>lastAbscissa<sp/>=<sp/>getInitialPointAbscissa();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Y<sp/>lastValue<sp/>=<sp/>getInitialPointOrdinate();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>end<sp/>=<sp/>mPointsMap.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(auto<sp/>it<sp/>=<sp/>mPointsMap.begin();<sp/>it<sp/>!=<sp/>end;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(abscissa<sp/>&gt;<sp/>lastAbscissa<sp/>&amp;&amp;<sp/>abscissa<sp/>&lt;=<sp/>it-&gt;first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>lastValue<sp/>=<sp/>it-&gt;second.second(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((double)abscissa<sp/>-<sp/>(double)lastAbscissa)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/<sp/>((double)it-&gt;first<sp/>-<sp/>(double)lastAbscissa),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastValue,<sp/>it-&gt;second.first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(abscissa<sp/>&gt;<sp/>it-&gt;first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>lastAbscissa<sp/>=<sp/>it-&gt;first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>lastValue<sp/>=<sp/>it-&gt;second.first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>lastValue;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">ossia::curve_type<sp/>curve_impl&lt;X,<sp/>Y&gt;::getType()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>std::make_pair(OssiaType&lt;X&gt;,<sp/>OssiaType&lt;Y&gt;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">X<sp/>curve_impl&lt;X,<sp/>Y&gt;::getInitialPointAbscissa()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto&amp;<sp/>node<sp/>=<sp/>mInitialPointAbscissaDestination.value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!node)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>mInitialPointAbscissa;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>address<sp/>=<sp/>node-&gt;getAddress();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!address)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>throw<sp/>std::runtime_error(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;getting<sp/>an<sp/>address<sp/>value<sp/>using<sp/>from<sp/>an<sp/>abscissa<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;destination<sp/>without<sp/>address&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>address-&gt;pullValue();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>val<sp/>=<sp/>address-&gt;cloneValue();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>res<sp/>=<sp/>convertToTemplateTypeValue(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>val,<sp/>mInitialPointAbscissaDestination.index.begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>res;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">Y<sp/>curve_impl&lt;X,<sp/>Y&gt;::getInitialPointOrdinate()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto&amp;<sp/>node<sp/>=<sp/>mInitialPointOrdinateDestination.value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!node)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>mInitialPointOrdinate;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(mInitialPointOrdinateCacheUsed)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>mInitialPointOrdinateCache;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>address<sp/>=<sp/>node-&gt;getAddress();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!address)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>throw<sp/>std::runtime_error(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;getting<sp/>an<sp/>address<sp/>value<sp/>using<sp/>from<sp/>an<sp/>ordinate<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;destination<sp/>without<sp/>address&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>address-&gt;pullValue();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>val<sp/>=<sp/>address-&gt;cloneValue();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mInitialPointOrdinateCacheUsed<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mInitialPointOrdinateCache<sp/>=<sp/>convertToTemplateTypeValue(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>val,<sp/>mInitialPointOrdinateDestination.index.begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>mInitialPointOrdinateCache;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>curve_impl&lt;X,<sp/>Y&gt;::setInitialPointAbscissa(X<sp/>value)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mInitialPointAbscissa<sp/>=<sp/>value;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>curve_impl&lt;X,<sp/>Y&gt;::setInitialPointOrdinate(Y<sp/>value)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mInitialPointOrdinate<sp/>=<sp/>value;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">const<sp/>ossia::Destination&amp;</highlight></codeline>
<codeline><highlight class="normal">curve_impl&lt;X,<sp/>Y&gt;::getInitialPointAbscissaDestination()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>mInitialPointAbscissaDestination;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">const<sp/>ossia::Destination&amp;</highlight></codeline>
<codeline><highlight class="normal">curve_impl&lt;X,<sp/>Y&gt;::getInitialPointOrdinateDestination()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>mInitialPointOrdinateDestination;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>curve_impl&lt;X,<sp/>Y&gt;::setInitialPointAbscissaDestination(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>ossia::Destination&amp;<sp/>destination)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mInitialPointAbscissaDestination<sp/>=<sp/>destination;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>curve_impl&lt;X,<sp/>Y&gt;::setInitialPointOrdinateDestination(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>ossia::Destination&amp;<sp/>destination)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mInitialPointOrdinateDestination<sp/>=<sp/>destination;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">std::map&lt;X,<sp/>std::pair&lt;Y,<sp/>ossia::curve_segment&lt;Y&gt;&gt;&gt;</highlight></codeline>
<codeline><highlight class="normal">curve_impl&lt;X,<sp/>Y&gt;::getPointsMap()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>{mPointsMap.cbegin(),<sp/>mPointsMap.cend()};</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X,<sp/>typename<sp/>Y&gt;</highlight></codeline>
<codeline><highlight class="normal">Y<sp/>curve_impl&lt;X,<sp/>Y&gt;::convertToTemplateTypeValue(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>ossia::value&amp;<sp/>value,<sp/>ossia::destination_index::const_iterator<sp/>idx)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>namespace<sp/>ossia;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>namespace<sp/>std;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>struct<sp/>visitor</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>destination_index::const_iterator<sp/>index;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(Int<sp/>i)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>i.value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(Float<sp/>f)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>f.value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(Bool<sp/>b)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>b.value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(Char<sp/>c)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>c.value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(Vec2f<sp/>vec)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>vec.value[*index];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(Vec3f<sp/>vec)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>vec.value[*index];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(Vec4f<sp/>vec)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>vec.value[*index];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(const<sp/>Tuple&amp;<sp/>t)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>auto&amp;<sp/>val<sp/>=<sp/>t.value[*index];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>convertToTemplateTypeValue(val,<sp/>index<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(Impulse)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>std::runtime_error(&quot;Cannot<sp/>convert<sp/>to<sp/>a<sp/>numeric<sp/>type&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(const<sp/>String&amp;<sp/>str)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>std::runtime_error(&quot;Cannot<sp/>convert<sp/>to<sp/>a<sp/>numeric<sp/>type&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(const<sp/>Destination&amp;<sp/>d)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>std::runtime_error(&quot;Cannot<sp/>convert<sp/>to<sp/>a<sp/>numeric<sp/>type&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()(const<sp/>Behavior&amp;)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>std::runtime_error(&quot;Cannot<sp/>convert<sp/>to<sp/>a<sp/>numeric<sp/>type&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Y<sp/>operator()()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>std::runtime_error(&quot;Invalid<sp/>variant&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>vis{idx};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>value.apply(vis);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/tmp/i-score/API/OSSIA/ossia/editor/curve/detail/Curve_impl.tpp"/>
  </compounddef>
</doxygen>
